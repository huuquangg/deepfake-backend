<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Real-Time Streaming - Deepfake Detection</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        .video-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 100%;
            max-width: 500px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #000;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        button.danger {
            background: #f44336;
        }
        button.danger:hover {
            background: #da190b;
        }
        .status {
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .stats {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .stats-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #dee2e6;
        }
        .stats-item:last-child {
            border-bottom: none;
        }
        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .config-row {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        input[type="text"], input[type="number"], select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 250px;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
        }
        .log-entry {
            margin: 5px 0;
        }
        .prediction-display {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .prediction-label {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }
        .prediction-label.real {
            color: #28a745;
        }
        .prediction-label.fake {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé• WebRTC Real-Time Video Streaming</h1>
        <p>Low-latency video streaming with automatic frame ingestion and deepfake detection</p>

        <div class="config-section">
            <h3>Configuration</h3>
            <div class="config-row">
                <label>Session ID:</label>
                <input type="text" id="sessionId" placeholder="e.g., user_123_test">
            </div>
            <div class="config-row">
                <label>Server URL:</label>
                <input type="text" id="serverUrl" value="http://localhost:8091">
            </div>
            <div class="config-row">
                <label>Target FPS:</label>
                <select id="targetFps">
                    <option value="15" selected>15 FPS (Recommended)</option>
                    <option value="20">20 FPS</option>
                    <option value="30">30 FPS</option>
                </select>
            </div>
            <div class="config-row">
                <label>Video Quality:</label>
                <select id="videoQuality">
                    <option value="480p" selected>480p (Low Latency)</option>
                    <option value="720p">720p (Balanced)</option>
                    <option value="1080p">1080p (High Quality)</option>
                </select>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="startStreaming()">üöÄ Start WebRTC Stream</button>
            <button id="stopBtn" onclick="stopStreaming()" disabled>‚èπÔ∏è Stop Stream</button>
            <button onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
        </div>

        <div id="status" class="status info">Status: Ready to start</div>

        <div class="video-section">
            <div>
                <h3>Local Camera</h3>
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div>
                <h3>Statistics</h3>
                <div class="stats" id="stats">
                    <div class="stats-item">
                        <span>Connection State:</span>
                        <span id="connState">Not connected</span>
                    </div>
                    <div class="stats-item">
                        <span>ICE State:</span>
                        <span id="iceState">Not connected</span>
                    </div>
                    <div class="stats-item">
                        <span>Frames Sent:</span>
                        <span id="framesSent">0</span>
                    </div>
                    <div class="stats-item">
                        <span>Data Sent:</span>
                        <span id="dataSent">0 KB</span>
                    </div>
                    <div class="stats-item">
                        <span>Bitrate:</span>
                        <span id="bitrate">0 Kbps</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="prediction-display" id="predictionDisplay" style="display: none;">
            <h3>Latest Prediction</h3>
            <div class="prediction-label" id="predictionLabel">REAL</div>
            <div class="stats">
                <div class="stats-item">
                    <span>Confidence:</span>
                    <span id="predictionConf">0%</span>
                </div>
                <div class="stats-item">
                    <span>Real Probability:</span>
                    <span id="predictionReal">0%</span>
                </div>
                <div class="stats-item">
                    <span>Fake Probability:</span>
                    <span id="predictionFake">0%</span>
                </div>
                <div class="stats-item">
                    <span>Inference Time:</span>
                    <span id="predictionTime">0 ms</span>
                </div>
            </div>
        </div>

        <h3>Logs</h3>
        <div class="log" id="logContainer">
            <div class="log-entry">[INFO] Ready to start WebRTC streaming</div>
        </div>
    </div>

    <script>
        let peerConnection = null;
        let localStream = null;
        let dataChannel = null;
        let framesChannel = null;
        let sessionId = '';
        let statsInterval = null;
        let frameInterval = null;
        let frameCounter = 0;

        function log(message, type = 'INFO') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${timestamp}] [${type}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(`[${type}] ${message}`);
        }

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = 'Status: ' + message;
            statusDiv.className = `status ${type}`;
            log(message, type.toUpperCase());
        }

        function clearLogs() {
            document.getElementById('logContainer').innerHTML = '';
            log('Logs cleared');
        }

        async function startStreaming() {
            try {
                // Get configuration
                sessionId = document.getElementById('sessionId').value;
                if (!sessionId) {
                    sessionId = 'session_' + Date.now();
                    document.getElementById('sessionId').value = sessionId;
                }

                const serverUrl = document.getElementById('serverUrl').value;
                const targetFps = parseInt(document.getElementById('targetFps').value);
                const videoQuality = document.getElementById('videoQuality').value;

                log(`Starting WebRTC stream for session: ${sessionId}`);
                updateStatus('Initializing camera...', 'info');

                // Get video constraints based on quality
                const constraints = getVideoConstraints(videoQuality, targetFps);

                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                document.getElementById('localVideo').srcObject = localStream;

                log('Camera access granted');
                updateStatus('Setting up WebRTC connection...', 'info');

                // Create peer connection
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                };

                peerConnection = new RTCPeerConnection(configuration);

                // Add tracks to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    log(`Added ${track.kind} track to peer connection`);
                });

                // Setup event handlers
                setupPeerConnectionHandlers(serverUrl);

                // Create data channel for sending frames
                framesChannel = peerConnection.createDataChannel('frames');
                setupFramesChannel();

                // Create data channel for receiving predictions
                dataChannel = peerConnection.createDataChannel('predictions');
                setupDataChannel();

                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                log('Created WebRTC offer');
                updateStatus('Sending offer to server...', 'info');

                // Send offer to server
                const response = await fetch(`${serverUrl}/api/video-streaming/webrtc/stream/offer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        sdp: offer.sdp,
                        type: offer.type
                    })
                });

                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${await response.text()}`);
                }

                const answer = await response.json();
                log('Received answer from server');

                // Set remote description
                await peerConnection.setRemoteDescription({
                    type: 'answer',
                    sdp: answer.sdp
                });

                log('WebRTC connection established');
                updateStatus('Streaming active', 'success');

                // Update UI
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;

                // Start stats monitoring
                startStatsMonitoring();

            } catch (error) {
                log(`Error: ${error.message}`, 'ERROR');
                updateStatus(`Failed: ${error.message}`, 'error');
                stopStreaming();
            }
        }

        function setupPeerConnectionHandlers(serverUrl) {
            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    log('Sending ICE candidate to server');
                    try {
                        await fetch(`${serverUrl}/api/video-streaming/webrtc/stream/candidate`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                session_id: sessionId,
                                candidate: event.candidate.toJSON()
                            })
                        });
                    } catch (error) {
                        log(`Failed to send ICE candidate: ${error.message}`, 'ERROR');
                    }
                }
            };

            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                log(`Connection state changed: ${state}`);
                document.getElementById('connState').textContent = state;

                if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                    updateStatus(`Connection ${state}`, 'error');
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                log(`ICE connection state changed: ${state}`);
                document.getElementById('iceState').textContent = state;
            };
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                log('Data channel opened - ready to receive predictions');
            };

            dataChannel.onmessage = (event) => {
                try {
                    const prediction = JSON.parse(event.data);
                    displayPrediction(prediction);
                } catch (error) {
                    log(`Error parsing prediction: ${error.message}`, 'ERROR');
                }
            };

            dataChannel.onclose = () => {
                log('Data channel closed');
            };
        }

        function setupFramesChannel() {
            framesChannel.onopen = () => {
                log('Frames channel opened - starting frame capture');
                startFrameCapture();
            };

            framesChannel.onclose = () => {
                log('Frames channel closed');
                stopFrameCapture();
            };

            framesChannel.onerror = (error) => {
                log(`Frames channel error: ${error}`, 'ERROR');
            };
        }

        function startFrameCapture() {
            const targetFps = parseInt(document.getElementById('targetFps').value);
            const intervalMs = 1000 / targetFps;
            
            frameCounter = 0;
            frameInterval = setInterval(() => {
                captureAndSendFrame();
            }, intervalMs);
            
            log(`Frame capture started at ${targetFps} FPS`);
        }

        function stopFrameCapture() {
            if (frameInterval) {
                clearInterval(frameInterval);
                frameInterval = null;
                log(`Frame capture stopped. Total frames sent: ${frameCounter}`);
            }
        }

        async function captureAndSendFrame() {
            if (!framesChannel || framesChannel.readyState !== 'open') {
                return;
            }

            try {
                const video = document.getElementById('localVideo');
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                
                // Convert to JPEG blob
                canvas.toBlob((blob) => {
                    if (blob && framesChannel && framesChannel.readyState === 'open') {
                        // Send as binary data
                        blob.arrayBuffer().then(buffer => {
                            framesChannel.send(buffer);
                            frameCounter++;
                            
                            if (frameCounter % 30 === 0) {
                                log(`Sent ${frameCounter} frames`);
                            }
                        });
                    }
                }, 'image/jpeg', 0.75);
            } catch (error) {
                log(`Frame capture error: ${error.message}`, 'ERROR');
            }
        }

        function displayPrediction(prediction) {
            const display = document.getElementById('predictionDisplay');
            const label = document.getElementById('predictionLabel');
            const conf = document.getElementById('predictionConf');
            const real = document.getElementById('predictionReal');
            const fake = document.getElementById('predictionFake');
            const time = document.getElementById('predictionTime');

            display.style.display = 'block';
            label.textContent = prediction.label.toUpperCase();
            label.className = `prediction-label ${prediction.label}`;
            conf.textContent = (prediction.confidence * 100).toFixed(2) + '%';
            real.textContent = (prediction.prob_real * 100).toFixed(2) + '%';
            fake.textContent = (prediction.prob_fake * 100).toFixed(2) + '%';
            time.textContent = prediction.inference_ms + ' ms';

            log(`Prediction: ${prediction.label} (${(prediction.confidence * 100).toFixed(1)}%)`, 
                prediction.label === 'fake' ? 'WARN' : 'INFO');
        }

        async function stopStreaming() {
            try {
                log('Stopping stream...');

                // Stop stats monitoring
                if (statsInterval) {
                    clearInterval(statsInterval);
                    statsInterval = null;
                }

                // Stop frame capture
                stopFrameCapture();

                // Close frames channel
                if (framesChannel) {
                    framesChannel.close();
                    framesChannel = null;
                }

                // Close data channel
                if (dataChannel) {
                    dataChannel.close();
                    dataChannel = null;
                }

                // Close peer connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }

                // Stop local stream
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }

                // Notify server
                const serverUrl = document.getElementById('serverUrl').value;
                try {
                    await fetch(`${serverUrl}/api/video-streaming/webrtc/stream/${sessionId}/close`, {
                        method: 'POST'
                    });
                    log('Server notified of stream closure');
                } catch (error) {
                    log(`Failed to notify server: ${error.message}`, 'WARN');
                }

                updateStatus('Stream stopped', 'info');

                // Update UI
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('connState').textContent = 'Not connected';
                document.getElementById('iceState').textContent = 'Not connected';

            } catch (error) {
                log(`Error stopping stream: ${error.message}`, 'ERROR');
            }
        }

        function startStatsMonitoring() {
            statsInterval = setInterval(async () => {
                if (!peerConnection) return;

                try {
                    const stats = await peerConnection.getStats();
                    let framesSent = 0;
                    let bytesSent = 0;
                    let bitrate = 0;

                    stats.forEach(stat => {
                        if (stat.type === 'outbound-rtp' && stat.kind === 'video') {
                            framesSent = stat.framesSent || 0;
                            bytesSent = stat.bytesSent || 0;
                            bitrate = stat.bitrate || (stat.bytesSent * 8 / 1000); // Kbps
                        }
                    });

                    document.getElementById('framesSent').textContent = framesSent;
                    document.getElementById('dataSent').textContent = (bytesSent / 1024).toFixed(2) + ' KB';
                    document.getElementById('bitrate').textContent = bitrate.toFixed(0) + ' Kbps';

                } catch (error) {
                    // Ignore stats errors
                }
            }, 1000);
        }

        function getVideoConstraints(quality, fps) {
            const constraints = {
                video: {
                    frameRate: { ideal: fps, max: fps },
                    facingMode: 'user'
                },
                audio: false
            };

            switch (quality) {
                case '480p':
                    constraints.video.width = { ideal: 640 };
                    constraints.video.height = { ideal: 480 };
                    break;
                case '720p':
                    constraints.video.width = { ideal: 1280 };
                    constraints.video.height = { ideal: 720 };
                    break;
                case '1080p':
                    constraints.video.width = { ideal: 1920 };
                    constraints.video.height = { ideal: 1080 };
                    break;
            }

            return constraints;
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (peerConnection) {
                stopStreaming();
            }
        });
    </script>
</body>
</html>
